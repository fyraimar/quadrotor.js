<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <style> * {margin:0;padding:0}</style>
    <script src="build/cannon.js"></script>
    <script src="libs/Three.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <style>
      html, body {
        width: 100%;
        height:100%;
      }
      body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
        font-family: ariel;
      }

      #blocker {
        position: absolute;

        width: 100%;
        height:100%;

        background-color: rgba (0,0,0,0.5);
      }

      #instructions {
        width: 100%;
        height:100%;

        display: -webkit-box;
        display: -moz-box;
        display: box;

        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;

        -webkit-box-pack: center;
        -moz-box-pack: center;
        box-pack: center;

        -webkit-box-align: center;
        -moz-box-align: center;
        -box-align: center;

        color: #ffffff;
        text-align: center;

        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">
        <span style="font-size:40px"> Click to play </span>
        <p> (W,A,S,D = Move, Space = Jump. Mouse = Look, Click = Shoot) </p>
      </div>
    </div>

    <script>
      var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], nallMeshes=[], boxes=[],boxMeshes=[], particles=[], particleMeshes=[];

      var camera, scene, renderer;
      var geometry, material, Material1, mesh;
      var controls, time = Date.now();

      var blocker = document.getElementById('blocker');
      var instructions = document.getElementById( 'instructions' );

      var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

      if ( havePointerLock ) {
        var element = document.body;

        var pointerlockchange = function (event) {
          if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
            controls.enabled = true;
            blocker.style.display = 'none' ;
            } else {
            controls.enabled = false;

            blocker.style.display = '-webkit-box';
            blocker.style.display = '-moz-box';
            blocker.style.display = '-box';

            instructions.style.display = '';

          }
        }

        var pointerlockerror = function ( event ) {
          instructions.style.display = '';
        }
        
        document.addEventListener( 'pointerlockchange', pointerlockchange, false );
        document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
        document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false);
        document.addEventListener( 'pointerlockerror', pointerlockerror, false );
        document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
        document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false);

        instructions.addEventListener( 'click', function (event) {
          instructions.style.display = 'none';

          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock ;
          if ( /Firefox/i.test (navigator.userAgent) ) {
            var fullscreenchange = function (event) {
              if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement == element ) {
                document.removeEventListener( 'fullscreenchange' , fullscreenchange );
                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
                element.requestPointerLock();
              }
            }
            document.addEventListener( 'fullscreenchange', fullscreenchange, false);
            document.addEventListener( 'mozfullscreenchange', fullscreenchange, false);
            element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
            element.requestFullscreen ();
            } else {
            element.requestPointerLock (); 
          }
        }, false );

        } else {
        instructions.innerHTML = 'Your browser dosen\'t seem to support Pointer Lock API';
      }

      initCannon();
      init();
      animate();

      function initCannon (){ 
        world = new CANNON.World();
        world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;

        var solver = new CANNON.GSSolver ();

        world.defaultContactMaterial.contactEquationStiffness = 1e9;
        world.defaultContactMaterial.contactEquationRegularizationTime = 4;

        solver.iteration = 10;
        solver.tolerance = 0.1;
        var split = true;
        if (split) 
          world.solver = new CANNON.SplitSolver(solver);
        else 
          world.solver = solver;

          world.gravity.set(0,-20,0);
          world.broadphase = new CANNON.NaiveBroadphase ();

          physicsMaterial = new CANNON.Material("slipperyMaterial");
          var physicsContactMaterial = new CANNON.ContactMaterial( physicsMaterial, physicsMaterial, 0.2, 0.3 );
          world.addContactMaterial(physicsContactMaterial);

          var mass = 1000, radius = 1.3;//We shouldn't affect the world.
          sphereShape = new CANNON.Sphere(radius);
          sphereBody = new CANNON.RigidBody (mass, sphereShape, physicsMaterial);
          sphereBody.position.set(0,1,10);
          sphereBody.linearDamping = 0.2;
          world.add(sphereBody);


          var groundShape = new CANNON.Plane();
          var groundBody = new CANNON.RigidBody( 0, groundShape, physicsMaterial);
          groundBody.quaternion.setFromAxisAngle (new CANNON.Vec3(1,0,0), -Math.PI/2);
          world.add(groundBody);
      }

      function init() {
          camera = new THREE.PerspectiveCamera (75, window.Width / window.innerHeight, 0.1, 1000);

          scene = new THREE.Scene();
          scene.fog = new THREE.Fog (0xbbbbbb, 0, 500);

          var ambient = new THREE.AmbientLight (0x111111);

          scene.add (ambient);
          
          
          light = new THREE.SpotLight (0xffffff);
          //light.position.set (10 ,30 ,20);
          light.position.set (-100 ,300 ,-200);
          light.target.position.set (0, 0, 0);
          if (true) {
            light.itensity = 0.5;
            light.castShadow = true;

            light.shadowCameraNear = 20;
            light.shadowCameraFar = 50;
            light.shadowCameraFov = 40;

            light.shadowMapBias = 0.1;
            light.shadowMapDarkness = 0.7;
            light.shadowMapWidth = 2 * 512;
            light.shadowMapHeight = 2 * 512;
          }
          scene.add (light);

          light = new THREE.SpotLight (0xffffff);
          //light.position.set (10 ,30 ,20);
          light.position.set (100 ,300 ,200);
          light.target.position.set (0, 0, 0);
          if (true) {
            light.itensity = 0.5;
            light.castShadow = true;

            light.shadowCameraNear = 20;
            light.shadowCameraFar = 50;
            light.shadowCameraFov = 40;

            light.shadowMapBias = 0.1;
            light.shadowMapDarkness = 0.7;
            light.shadowMapWidth = 2 * 512;
            light.shadowMapHeight = 2 * 512;
          }
          scene.add (light);

          controls = new PointerLockControls (camera, sphereBody);
          scene.add (controls.getObject());

          geometry = new THREE.PlaneGeometry (300, 300, 50, 50);
          geometry.applyMatrix (new THREE.Matrix4().makeRotationX( - Math.PI / 2 ));
          material = new THREE.MeshLambertMaterial( {color:0xbbbbbb} );
          material1 = new THREE.MeshLambertMaterial( {color:0x0} );
          THREE.ColorUtils.adjustHSV (material.color, 0, 0, 0.9);

          mesh = new THREE.Mesh (geometry, material);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add ( mesh );

          renderer = new THREE.WebGLRenderer();
          renderer.shadowMapEnabled = true;
          renderer.shadowMapSoft = true;
          renderer.setSize ( window.innerWidth, window.innerHeight );
          renderer.setClearColor (scene.fog.color, 1);

          document.body.appendChild (renderer.domElement);

          window.addEventListener("resize", onWindowResize, false);
          //addBox (1,1,1,10, 10, 10);
          //addBox (1,1,1,-10, 10, 10);
          //addBox (1,1,1,10, 10, -10);
          //addBox (1,1,1,-10,10,-10);
          addQua (2*Math.sqrt(2),1.5,1);
          particles[1].velocity = new CANNON.Vec3(10,5000,10);
        }
        function addQua ( innerLen, outerLen, particalMass, noise ) {
          direction = [1,1,-1,-1,1,-1,-1,1];
          //points except center 
          for (var i=0 ; i < 4; i ++) {
            var innerParticleUp = new CANNON.Particle (particalMass);
            var outerParticleUp = new CANNON.Particle (particalMass);
            var innerParticleDown = new CANNON.Particle (particalMass);
            var outerParticleDown = new CANNON.Particle (particalMass);
            innerParticleUp.position.set ( -5 + direction[i*2] * innerLen ,10, -5 + direction[i*2+1] * innerLen );
            outerParticleUp.position.set ( -5 + direction[i*2] * outerLen ,10, -5 + direction[i*2+1] * outerLen );
            innerParticleDown.position.set ( -5 + direction[i*2] * innerLen ,9, -5 + direction[i*2+1] * innerLen );
            outerParticleDown.position.set ( -5 + direction[i*2] * outerLen ,9, -5 + direction[i*2+1] * outerLen );
            particles.push (innerParticleUp);
            particles.push (outerParticleUp);
            particles.push (innerParticleDown);
            particles.push (outerParticleDown);

            var innerBallUp = new THREE.SphereGeometry(0.1);
            var outerBallUp = new THREE.SphereGeometry(0.1);
            var innerBallDown = new THREE.SphereGeometry(0.1);
            var outerBallDown = new THREE.SphereGeometry(0.1);
            var innerBallMeshUp = new THREE.Mesh (innerBallUp, material1);
            var outerBallMeshUp = new THREE.Mesh (outerBallUp, material1);
            var innerBallMeshDown = new THREE.Mesh (innerBallDown, material1);
            var outerBallMeshDown = new THREE.Mesh (outerBallDown, material1);

            innerBallMeshUp.position.set ( -5 + direction[i*2] * innerLen ,10, -5 + direction[i*2+1] * innerLen );
            outerBallMeshUp.position.set ( -5 + direction[i*2] * innerLen ,10, -5 + direction[i*2+1] * innerLen );
            innerBallMeshDown.position.set ( -5 + direction[i*2] * innerLen ,9, -5 + direction[i*2+1] * innerLen );
            outerBallMeshDown.position.set ( -5 + direction[i*2] * innerLen ,9, -5 + direction[i*2+1] * innerLen );

            innerBallMeshUp.castShadow = true;
            outerBallMeshUp.castShadow = true;
            innerBallMeshDown.castShadow = true;
            outerBallMeshDown.castShadow = true;

            innerBallMeshUp.receiveShadow = true;
            outerBallMeshUp.receiveShadow = true;
            innerBallMeshDown.receiveShadow = true;
            outerBallMeshDown.receiveShadow = true;

            innerBallMeshUp.useQuaternion = true;
            outerBallMeshUp.useQuaternion = true;
            innerBallMeshDown.useQuaternion = true;
            outerBallMeshDown.useQuaternion = true;

            particleMeshes.push(innerBallMeshUp);
            particleMeshes.push(outerBallMeshUp);
            particleMeshes.push(innerBallMeshDown);
            particleMeshes.push(outerBallMeshDown);
            world.add (innerParticleUp);
            world.add (outerParticleUp);
            world.add (innerParticleDown);
            world.add (outerParticleDown);
            scene.add (innerBallMeshUp);
            scene.add (outerBallMeshUp);
            scene.add (innerBallMeshDown);
            scene.add (outerBallMeshDown);
          }
          //center point


          var centerParticleUp = new CANNON.Particle(particalMass);
          var centerParticleDown = new CANNON.Particle(particalMass);
          centerParticleUp.position.set (-5,10,-5);
          centerParticleDown.position.set (-5,9,-5);
          particles.push(centerParticleUp);
          particles.push(centerParticleDown);

          var centerBallUp = new THREE.SphereGeometry (0.1);
          var centerBallDown = new THREE.SphereGeometry (0.1);
          var centerBallMeshUp = new THREE.Mesh (centerBallUp, material1);
          var centerBallMeshDown = new THREE.Mesh (centerBallUp, material1);

          centerBallMeshUp.position.set (-5,10,-5);
          centerBallMeshDown.position.set (-5,9,-5);

          centerBallMeshUp.castShadow = true;
          centerBallMeshUp.receiveShadow = true;
          centerBallMeshUp.useQuaternion = true;
          centerBallMeshDown.castShadow = true;
          centerBallMeshDown.receiveShadow = true;
          centerBallMeshDown.useQuaternion = true;

          particleMeshes.push (centerBallMeshUp);
          particleMeshes.push (centerBallMeshDown);
          world.add (centerParticleUp);
          world.add (centerParticleDown);
          scene.add (centerBallMeshUp);
          scene.add (centerBallMeshDown);

          pointCloudConstraint ();


        }

        function pointCloudConstraint () {
          for ( var i = 0 ; i < particles.length - 1; i ++ ) {
            for ( var j = i + 1 ; j < particles.length; j ++ ) {
              world.addConstraint (new CANNON.DistanceConstraint( particles[i], particles[j], distof (particles[i], particles[j]) , 1e9) );
            }
          }
        }

        function distof (a,b) {
          return  Math.sqrt (
                (a.position.x - b.position.x) * (a.position.x - b.position.x) + 
                (a.position.y - b.position.y) * (a.position.y - b.position.y) + 
                (a.position.z - b.position.z) * (a.position.z - b.position.z) );
        }

        function addBox (length, width, height, x, y, z) {
          var halfExtents = new CANNON.Vec3(length, width, height);
          var boxShape = new CANNON.Box(halfExtents);
          var boxGeometry = new THREE.CubeGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);

          var boxBody = new CANNON.RigidBody (5, boxShape);
          var boxMesh = new THREE.Mesh(boxGeometry, material1);
          world.add(boxBody);
          scene.add(boxMesh);
          boxBody.position.set(x,y,z);
          boxMesh.position.set(x,y,z);
          boxMesh.castShadow = true;
          boxMesh.receiveShadow = true;
          boxMesh.useQuaternion = true;
          boxes.push(boxBody);
          boxMeshes.push(boxMesh);
        }

        function onWindowResize () {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize ( window.innerWidth, window.innerHeight);
        }

        var dt = 1/60;
        function animate() {
          requestAnimationFrame( animate );
          if (controls.enabled) {
            world.step (dt);

            for (var i=0; i<particles.length; i++ ) {
              particles[i].position.copy (particleMeshes[i].position);
              //  particles[i].quaternion.copy (particleMeshes[i].quaternion);
              console.log(i);
            }
            for (var i=0; i<balls.length; i ++) {
              balls[i].position.copy (ballMeshes[i].position);
              balls[i].quaternion.copy(ballMeshes[i].quaternion);
            }
            for (var i=0; i<boxes.length; i ++) {
              boxes[i].position.copy (boxMeshes[i].position);
              boxes[i].quaternion.copy(boxMeshes[i].quaternion);
            }
          }
          controls.update (Date.now() - time);
          renderer.render (scene, camera);
          time = Date.now();

        }

      </script>
    </body>
  </html>
