<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <style> * {margin:0;padding:0}</style>
    <script src="build/cannon.js"></script>
    <script src="libs/Three.js"></script>
    <script src="js/PointerLockControls.js"></script>
	<script src="quad_particle.js"></script>
    <style>
      html, body {
        width: 100%;
        height:100%;
      }
      body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
        font-family: ariel;
      }

      #blocker {
        position: absolute;

        width: 100%;
        height:100%;

        background-color: rgba (0,0,0,0.5);
      }

      #instructions {
        width: 100%;
        height:100%;

        display: -webkit-box;
        display: -moz-box;
        display: box;

        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;

        -webkit-box-pack: center;
        -moz-box-pack: center;
        box-pack: center;

        -webkit-box-align: center;
        -moz-box-align: center;
        -box-align: center;

        color: #ffffff;
        text-align: center;

        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">
        <span style="font-size:40px"> Click to play </span>
        <p> (W,A,S,D = Move, Space = Jump. Mouse = Look, Click = Shoot) </p>
      </div>
    </div>

    <script>
      var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], nallMeshes=[], boxes=[],boxMeshes=[];

      var camera, scene, renderer;
      var geometry, material, mesh;
      var controls, time = Date.now();

      var blocker = document.getElementById('blocker');
      var instructions = document.getElementById( 'instructions' );

      var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

	  //-------------- Model ---------------
	  var quadrotor = new quadrotor_ParticleModel();
	  
      if ( havePointerLock ) {
        var element = document.body;

        var pointerlockchange = function (event) {
          if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
            controls.enabled = true;
            blocker.style.display = 'none' ;
            } else {
            controls.enabled = false;

            blocker.style.display = '-webkit-box';
            blocker.style.display = '-moz-box';
            blocker.style.display = '-box';

            instructions.style.display = '';

          }
        }

        var pointerlockerror = function ( event ) {
          instructions.style.display = '';
        }
        
        document.addEventListener( 'pointerlockchange', pointerlockchange, false );
        document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
        document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false);
        document.addEventListener( 'pointerlockerror', pointerlockerror, false );
        document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
        document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false);

        instructions.addEventListener( 'click', function (event) {
          instructions.style.display = 'none';

          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock ;
          if ( /Firefox/i.test (navigator.userAgent) ) {
            var fullscreenchange = function (event) {
              if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement == element ) {
                document.removeEventListener( 'fullscreenchange' , fullscreenchange );
                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
                element.requestPointerLock();
              }
            }
            document.addEventListener( 'fullscreenchange', fullscreenchange, false);
            document.addEventListener( 'mozfullscreenchange', fullscreenchange, false);
            element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
            element.requestFullscreen ();
            } else {
            element.requestPointerLock (); 
          }
        }, false );

        } else {
        instructions.innerHTML = 'Your browser dosen\'t seem to support Pointer Lock API';
      }

      initCannon();
      init();
      animate();

      function initCannon (){ 
        world = new CANNON.World();
        world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;

        var solver = new CANNON.GSSolver ();

        world.defaultContactMaterial.contactEquationStiffness = 1e9;
        world.defaultContactMaterial.contactEquationRegularizationTime = 4;

        solver.iteration = 10;
        solver.tolerance = 1e-6;
        var split = true;
        if (split) 
          world.solver = new CANNON.SplitSolver(solver);
        else 
          world.solver = solver;

          world.gravity.set(0,0,-10);
          world.broadphase = new CANNON.NaiveBroadphase ();

          physicsMaterial = new CANNON.Material("slipperyMaterial");
          var physicsContactMaterial = new CANNON.ContactMaterial( physicsMaterial, physicsMaterial, 0.2, 0.3 );
          world.addContactMaterial(physicsContactMaterial);

          var mass = 1000, radius = 1.3;//We shouldn't affect the world.
          sphereShape = new CANNON.Sphere(radius);
          sphereBody = new CANNON.RigidBody (mass, sphereShape, physicsMaterial);
          sphereBody.position.set(0,1,1);
          sphereBody.linearDamping = 0.2;
          world.add(sphereBody);
		  
          var groundShape = new CANNON.Plane();
          var groundBody = new CANNON.RigidBody( 0, groundShape, physicsMaterial);
          //groundBody.quaternion.setFromAxisAngle (new CANNON.Vec3(1,0,0), Math.PI);
          world.add(groundBody);
      }

      function init() {
          camera = new THREE.PerspectiveCamera (75, window.Width / window.innerHeight, 0.1, 1000);

          scene = new THREE.Scene();
          scene.fog = new THREE.Fog (0xbbbbbb, 0, 500);

          var ambient = new THREE.AmbientLight (0x111111);

          scene.add (ambient);
          
          
          light = new THREE.SpotLight (0xffffff);
          //light.position.set (10 ,30 ,20);
          light.position.set (-100 ,-200 ,300);
          light.target.position.set (0, 0, 0);
          if (true) {
            light.itensity = 0.5;
            light.castShadow = true;

            light.shadowCameraNear = 20;
            light.shadowCameraFar = 50;
            light.shadowCameraFov = 40;

            light.shadowMapBias = 0.1;
            light.shadowMapDarkness = 0.7;
            light.shadowMapWidth = 2 * 512;
            light.shadowMapHeight = 2 * 512;
          }
          scene.add (light);

          light = new THREE.SpotLight (0xffffff);
          //light.position.set (10 ,30 ,20);
          light.position.set (100 ,200 ,300);
          light.target.position.set (0, 0, 0);
          if (true) {
            light.itensity = 0.5;
            light.castShadow = true;

            light.shadowCameraNear = 20;
            light.shadowCameraFar = 50;
            light.shadowCameraFov = 40;

            light.shadowMapBias = 0.1;
            light.shadowMapDarkness = 0.7;
            light.shadowMapWidth = 2 * 512;
            light.shadowMapHeight = 2 * 512;
          }
          scene.add (light);

          controls = new PointerLockControls (camera, sphereBody);
          scene.add (controls.getObject());

          geometry = new THREE.PlaneGeometry (300, 300, 50, 50);
          geometry.applyMatrix (new THREE.Matrix4().makeRotationZ( -Math.PI/2 ));
          material = new THREE.MeshLambertMaterial( {color:0xbbbbbb} );
          THREE.ColorUtils.adjustHSV (material.color, 0, 0, 0.9);

          mesh = new THREE.Mesh (geometry, material);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add ( mesh );

          renderer = new THREE.WebGLRenderer();
          renderer.shadowMapEnabled = true;
          renderer.shadowMapSoft = true;
          renderer.setSize ( window.innerWidth, window.innerHeight );
          renderer.setClearColor (scene.fog.color, 1);

          document.body.appendChild (renderer.domElement);

          window.addEventListener("resize", onWindowResize, false);
          //addBox (1,1,1,10, 10, 10);
          //addBox (1,1,1,-10, 10, 10);
          //addBox (1,1,1,10, 10, -10);
          //addBox (1,1,1,-10,10,-10);
		  
			// model mass = 0.035 or 0.036
			quadrotor.constructModel(0.5, 1.2, 0.5,
			/*	[0.1, 0.1, 0.1, 0.1,
				 0.1, 0.1, 0.1, 0.1,
				 0.1, 0.1, 0.1, 0.1,
				 0.1, 0.1, 0.1, 0.1,
				 8.2, 8.2]);*/
				[0.0018, 0.0018, 0.0018, 0.0018,
				 0.0018, 0.0018, 0.0018, 0.0018,
				 0.0018, 0.0018, 0.0018, 0.0018,
				 0.0018, 0.0018, 0.0018, 0.0018,
				 0.0031, 0.0031]);
			quadrotor.showModel(world, scene);
        }
        /*
        function addBox (length, width, height, x, y, z) {
          var halfExtents = new CANNON.Vec3(length, width, height);
          var boxShape = new CANNON.Box(halfExtents);
          var boxGeometry = new THREE.CubeGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);

          var boxBody = new CANNON.RigidBody (5, boxShape);
          var boxMesh = new THREE.Mesh(boxGeometry, material1);
          world.add(boxBody);
          scene.add(boxMesh);
          boxBody.position.set(x,y,z);
          boxMesh.position.set(x,y,z);
          boxMesh.castShadow = true;
          boxMesh.receiveShadow = true;
          boxMesh.useQuaternion = true;
          boxes.push(boxBody);
          boxMeshes.push(boxMesh);
        }
*/
        function onWindowResize () {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize ( window.innerWidth, window.innerHeight);
        }

        var dt = 1/60;
			var f1 = new CANNON.Vec3(0,0,66);	//X+
			var f2 = new CANNON.Vec3(0,0,66);	//X-
			var f3 = new CANNON.Vec3(0,0,66);	//Y+
			var f4 = new CANNON.Vec3(0,0,66);	//Y-
		var counter = 0;
        function animate() {
          requestAnimationFrame( animate );
          if (controls.enabled) {
            world.step (dt);
					
			//quadrotor.getAngleX();
			//var forceArr = [f1,f2,f3,f4];
			//quadrotor.setModelForce_norm(forceArr);
			quadrotor.setModelPin([124,124,124,124]);
			
			quadrotor.updateAnimate();
            
            for (var i=0; i<balls.length; i ++) {
              balls[i].position.copy (ballMeshes[i].position);
              balls[i].quaternion.copy(ballMeshes[i].quaternion);
            }
			/*
            for (var i=0; i<boxes.length; i ++) {
              boxes[i].position.copy (boxMeshes[i].position);
              boxes[i].quaternion.copy(boxMeshes[i].quaternion);
            }*/
          }
          controls.update (Date.now() - time);
          renderer.render (scene, camera);
          time = Date.now();

        }

      </script>
    </body>
  </html>
